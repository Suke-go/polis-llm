# Polisスタイルの意見空間クラスタリング・パイプライン仕様書

このドキュメントは、Polis が内部で用いているクラスタリング・可視化アルゴリズムを、他の AI エージェントでも再実装できるように整理したものです。
参加者 × コメントの投票行列（賛成=+1 / 反対=-1 / パス=0）から、意見グループと代表コメントを抽出する一連の処理をまとめています。

---

## 0. 用語

* **参加者 (participant)**: アンケート・対話に参加した人。インデックス `i`。
* **コメント (comment / statement)**: 投票対象の文。インデックス `j`。
* **投票 v**:

  * 賛成: `+1`
  * 反対: `-1`
  * パス（わからない / スキップ）: `0`
* **グループ (opinion group)**: 意見の近い参加者で構成されるクラスタ。インデックス `g`。
* **会話 (conversation)**: 一つのテーマに対する参加者・コメント・投票の集合。

---

## 1. 全体パイプライン概要

1. **投票行列の構築**

   * 参加者を行、コメントを列とする行列 `V` を作る。
   * 要素 `v_{i,j} ∈ {+1, -1, 0}`（未投票は欠損）。
   * 欠損値の補完・参加者フィルタリングを行う。

2. **次元削減 (PCA) による「意見空間」構築**

   * `V` を PCA で 2 次元に射影し、参加者を 2D 平面上の点として配置。
   * 投票数の少ない参加者は中心に寄りやすいため、補正スケーリングを行う。

3. **K-means によるクラスタリング**

   * まず K=100 の細粒度クラスタリング（マイクロクラスタ）。
   * そのクラスタ中心をさらに K=2〜5 でクラスタリングし、シルエット係数に基づき最適な K を選ぶ。

4. **代表コメント・分断コメントの抽出**

   * 各グループごとに、
     「このグループらしさ」をよく表すコメントを統計的に選ぶ。
   * 代表性指標 `R_v(g,c)` と Fisher の正確検定（2×2 分割表）から算出した統計量を組み合わせる。

5. **グループ横断のコンセンサスの計算**

   * 全グループで賛成されているコメントを抽出するための、グループ意識的コンセンサス指標 `C_v(c)` を計算。

6. **コメントルーティング（任意）**

   * どのコメントを優先的に誰に見せるかを決める優先度スコアを計算し、対話の効率を上げる。

---

## 2. データモデルと前処理

### 2.1 投票行列

* 行列 `V ∈ ℝ^{N_p × N_c}`

  * `N_p`: 参加者数
  * `N_c`: コメント数
* 要素:

  * `v_{i,j} = +1`（賛成）
  * `v_{i,j} = -1`（反対）
  * `v_{i,j} = 0`（パス）
  * 未投票は欠損（NA）

### 2.2 欠損値の補完 (column-wise mean imputation)

* 各列（コメント）ごとに、非欠損値の平均 `μ_j` を計算。
* `v_{i,j}` が欠損の場合、その列の平均 `μ_j` を代入。
* これは「標準的な列平均補完」として採用されている。

### 2.3 参加者フィルタリング

* 投票数が少なすぎる参加者は、意見空間で中心に「固まる」傾向があるため除外。
* Polis では「**7コメント未満**」しか投票していない参加者を除外する。
* ハイパーパラメータとして、`min_votes_per_participant` を持たせる。

### 2.4 モデレーション後コメントの採用

* 別プロセスでモデレーションされ、「本番可」とされたコメントのみを列として採用。
* 以降の分析はこのフィルタ済みコメント集合を前提とする。

---

## 3. 次元削減: PCA による 2D 意見空間

### 3.1 PCA の実行

* 投票行列 `V` を列方向にセンタリング（各列の平均を引く）。
* PCA により 2 つの主成分を抽出し、参加者 i を 2D ベクトル `x_i ∈ ℝ^2` に射影。
* Polis 実装では power iteration 法を用いており、オンライン更新に対応（新しい投票が入ったときに再計算を効率化）。

### 3.2 投票数による位置補正

* 少ないコメント数しか投票していない参加者は、平均補完の影響で原点付近に寄る。

* その補正として、以下のスケーリングを適用：

* 記号:

  * `C`: 会話全体のコメント数
  * `C_p`: 参加者 p が投票したコメント数
  * `x_p`: PCA で得た 2D 位置

* 補正:

  * `x'_p = x_p * sqrt(C / C_p)`

* 直感:

  * `C_p` が小さいほど、参加者が探索した「意見空間の分散」が少ないとみなし、外側に押し出す。

---

## 4. クラスタリング: 意見グループの抽出

### 4.1 マイクロクラスタ (K=100)

* 2D の位置 `x_i` を K-means (Lloyd のアルゴリズム) で K=100 クラスタに分割。
* 目的:

  * パフォーマンス最適化（ビジュアライゼーション更新の際のデータ量削減）。
  * 後段のクラスタリングのための粗いグリッドとして機能。

### 4.2 マクロクラスタ (K=2〜5)

1. 各マイクロクラスタの重心（平均位置）を計算。
2. その重心集合に対し、K=2,3,4,5 で K-means を実行。
3. 各 K に対してシルエット係数を計算し、最も良い K を採用。
4. 意見グループはこの最終 K-means のクラスタとして定義。

### 4.3 K のスムージング

* 投票が増えるにつれ、最適な K が一時的に揺れ動くことがある。
* 可視化の安定性のため、「**同じ K が 4 回連続で最適**になったときだけ K を変更」するスムージングを適用する。

---

## 5. コメント代表性と統計的選択

### 5.1 代表性指標 ( R_v(g,c) )

* 目的:
  「グループ g の参加者は、外の人よりもどれくらいそのコメントに賛成/反対しがちか」を定量化。

* 記号:

  * `N_v(g,c)`: グループ g に所属し、コメント c に投票 v を行った参加者数
  * `N(g,c)`: グループ g でコメント c に対して投票をした総数
  * `P_v(g,c)`: グループ g の任意参加者がコメント c に v を投票する確率の推定値

* 推定:

  * `P_v(g,c) = (1 + N_v(g,c)) / (2 + N(g,c))`

    * `1` と `2` は疑似カウント（pseudocount）で、票がないとき `P=1/2` になるようにしている。

* グループ外（補集合）を `\bar g` とすると、

  * `P_v( ḡ , c)` も同様に計算。

* 代表性（相対オッズ比）:

  * 実装上は「**確率比**」として

    * `R_v(g,c) = P_v(g,c) / P_v( ḡ , c)`
      と解釈できる（グループ内の賛成確率が、外の何倍か）。

### 5.2 Fisher の正確検定と Z 統計量

* コメント c とグループ g の関係について、賛成/非賛成（v vs それ以外）× グループ内/外の 2×2 分割表を作る。
* Fisher の正確検定を行い、Z 統計量（効果の有意性）を算出。

### 5.3 スコアリングと代表コメント選択

* 各 (g, c, v) について

  * 「強さ＝`Z_Fisher(g,c,v) × R_v(g,c)`」
  * 効果量（どれだけグループらしいか）と統計的な確信を両方反映。
* 選択手順（Polis 論文に基づく簡略イメージ）:

  1. 各グループ g でコメント c と投票種 v（賛成、反対）についてスコアを計算。
  2. まず「賛成」に対して代表的なコメントを優先的に選ぶ。
  3. 賛成側に適切な代表コメントがない場合、反対側の代表コメントを採用する。

---

## 6. グループ意識的コンセンサス指標 ( C_v(c) )

* 目的:
  「すべての意見グループが賛成しているコメント」を見つけること。
* 定義:

  * `C_v(c) = ∏_{g ∈ G} P_{v=a}(g, c)`

    * ここで `v=a` は「賛成」票を指す。
* 解釈:

  * 各グループで賛成される確率を掛け合わせるので、どこか一つのグループでも賛成が低いと値が小さくなる。
  * 全グループが高い賛成率を示すコメントは `C_v(c)` が大きくなり、「少数派の意見も踏まえた合意点」として機能する。

---

## 7. コメントルーティング（任意）

* 参加者の時間を最大限活かすため、「どのコメントを優先的に見せるか」を決める優先度スコア `Priority(c)` を計算。
* 概要:

  * 全体として賛成率が高いコメント（コンセンサスに寄与する）
  * パスされにくいコメント
  * PCA 上で極端な位置にあるコメント（意見空間での情報量が高い）
  * まだ投票数が少ないコメント（探索すべき）
* これらを掛け合わせたスコアを二乗するなどして、優先表示コメントを決定する。

---

## 8. AI エージェントへの引き継ぎ用メモ

他の LLM / AI エージェントでこのパイプラインを再現・拡張する際のポイント:

1. **入力フォーマット**

   * `participants`: 一意な参加者 ID のリスト
   * `comments`: 一意なコメント ID とテキスト（＋モデレーションフラグ）
   * `votes`: `(participant_id, comment_id, vote)` の三つ組（vote ∈ {-1,0,+1}）

2. **前処理のハイパーパラメータ**

   * `min_votes_per_participant`（初期値: 7）
   * 欠損補完: 列平均（必要に応じて他の補完手法に差し替え可能）

3. **次元削減**

   * まずは PCA (2D) を前提とした実装でよいが、UMAP など他の手法に差し替え可能。([compdemocracy.org][1])

4. **クラスタリング**

   * マイクロクラスタ: K=100 の K-means（2D 空間）
   * マクロクラスタ: K=2〜5 を試し、シルエット係数最大のものを採用
   * K のスムージング（同じ K が 4 連続で最適になったときに更新）

5. **グループ特徴抽出**

   * `R_v(g,c)` と Fisher 統計量で代表コメントを算出
   * 代表コメントをグループごとにランキングしておく

6. **コンセンサス抽出**

   * `C_v(c)` を計算し、コンセンサス度の高いコメントをランキング
   * 「意見の対立軸」と「合意の核」を可視化する UI（Polis ライクな donut グラフなど）に渡す。

7. **APS やポリシーデザインとの接続**

   * APS（Abstract Proposition Segmentation）で抽出された命題を「コメント」として扱い、同様の投票・クラスタリングパイプラインに投入できる。
   * 「どの命題がどの意見グループの対立軸になっているか」「どの命題にコンセンサスがあるか」を可視化することで、

     * SF プロトタイピングで生まれたストーリーライン
     * Society5.0 的な政策オプション
       を、参加者の実際の反応と結びつけて評価することが可能。

---

このまま `.md` として保存すれば、別のエージェントに「Polis スタイルの意見空間クラスタリングをこういう仕様で実装して」と渡せるはずです。
次のステップとして、「APS から得た命題をどのようにコメント集合として投入するか」「街づくり・政策案の SF プロトタイピングとの接続」を一緒に設計していけます。

[1]: https://compdemocracy.org/algorithms/?utm_source=chatgpt.com "Algorithms"
